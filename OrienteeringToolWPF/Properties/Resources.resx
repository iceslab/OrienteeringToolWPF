<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="CannotFindStation" xml:space="preserve">
    <value>Nie odnaleziono stacji</value>
  </data>
  <data name="CategoryName" xml:space="preserve">
    <value>Kategoria</value>
  </data>
  <data name="CheckTimeFormat" xml:space="preserve">
    <value>Czas kontroli: {0:H:mm:ss}</value>
  </data>
  <data name="ChipNumberFormat" xml:space="preserve">
    <value>Numer chipa: {0}</value>
  </data>
  <data name="CompetitionCannotStart" xml:space="preserve">
    <value>Nie można rozpocząć zakończonych zawodów.</value>
  </data>
  <data name="CompetitionHasFinished" xml:space="preserve">
    <value>Zawody zostały zakończone</value>
  </data>
  <data name="CompetitorBirthDate" xml:space="preserve">
    <value>Data urodzenia</value>
  </data>
  <data name="CompetitorCategory" xml:space="preserve">
    <value>Kategoria</value>
  </data>
  <data name="CompetitorChip" xml:space="preserve">
    <value>Chip</value>
  </data>
  <data name="CompetitorName" xml:space="preserve">
    <value>Imię i nazwisko</value>
  </data>
  <data name="CompetitorRelay" xml:space="preserve">
    <value>Sztafeta</value>
  </data>
  <data name="ConnectionNeeddedInfo" xml:space="preserve">
    <value>Aby móc rozpocząć lub kontynuować zawody należy połączyć się ze stacją.
Spróbować ponownie?</value>
  </data>
  <data name="ConnectionNotConnected" xml:space="preserve">
    <value>Nie połączono się ze stacją</value>
  </data>
  <data name="ConnectionWindowUsage" xml:space="preserve">
    <value>Naciśnij "Wyszukaj" aby znaleźć stację</value>
  </data>
  <data name="CreateKCDatabase" xml:space="preserve">
    <value>--
-- Plik wygenerowany przez SQLiteStudio v3.0.7 dnia Pn wrz 5 19:31:30 2016
--
-- Użyte kodowanie tekstu: windows-1250
--
PRAGMA foreign_keys = off;
BEGIN TRANSACTION;

-- Tabela: TOURNAMENT
DROP TABLE IF EXISTS TOURNAMENT;
CREATE TABLE TOURNAMENT (ID INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT, START_TIME DATETIME NOT NULL, STARTED_AT_TIME DATETIME, FINISHED_AT_TIME DATETIME, NAME VARCHAR (255) NOT NULL, COURSE_TYPE INTEGER NOT NULL, DESCRIPTION TEXT);

-- Tabela: PROJECT_INFO
DROP TABLE IF EXISTS PROJECT_INFO;
CREATE TABLE [PROJECT_INFO] (
[ID] INTEGER  NOT NULL PRIMARY KEY AUTOINCREMENT,[TOURNAMENT_TYPE] INTEGER  NOT NULL);

-- Tabela: CATEGORIES
DROP TABLE IF EXISTS CATEGORIES;
CREATE TABLE CATEGORIES (ID INTEGER PRIMARY KEY UNIQUE NOT NULL, NAME VARCHAR (255) NOT NULL UNIQUE);

-- Tabela: COMPETITORS
DROP TABLE IF EXISTS COMPETITORS;
CREATE TABLE COMPETITORS (ID INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, NAME VARCHAR (128) NOT NULL, CHIP INTEGER UNIQUE NOT NULL, RELAY_ID INTEGER NOT NULL REFERENCES RELAYS (ID) ON DELETE CASCADE, CATEGORY INTEGER NOT NULL, GENDER INTEGER NOT NULL, BIRTH_DATE DATE NOT NULL);

-- Tabela: ROUTE_STEPS
DROP TABLE IF EXISTS ROUTE_STEPS;
CREATE TABLE ROUTE_STEPS (ID INTEGER PRIMARY KEY AUTOINCREMENT UNIQUE NOT NULL, "ORDER" INTEGER NOT NULL, CODE INTEGER NOT NULL, ROUTE_ID INTEGER REFERENCES ROUTES (ID) ON DELETE CASCADE NOT NULL);

-- Tabela: RELAYS
DROP TABLE IF EXISTS RELAYS;
CREATE TABLE [RELAYS] (
[ID] INTEGER  PRIMARY KEY AUTOINCREMENT NOT NULL,
[NAME] VARCHAR(255)  UNIQUE NOT NULL
);

-- Tabela: RESULTS
DROP TABLE IF EXISTS RESULTS;
CREATE TABLE RESULTS (CHIP INTEGER PRIMARY KEY NOT NULL REFERENCES COMPETITORS (CHIP) ON DELETE CASCADE, START_TIME INTEGER NOT NULL, CHECK_TIME INTEGER NOT NULL, FINISH_TIME INTEGER NOT NULL);

-- Tabela: PUNCHES
DROP TABLE IF EXISTS PUNCHES;
CREATE TABLE PUNCHES (ID INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, CHIP INTEGER NOT NULL REFERENCES COMPETITORS (CHIP) ON DELETE CASCADE, CODE INTEGER NOT NULL, TIMESTAMP INTEGER NOT NULL);

-- Tabela: ROUTES
DROP TABLE IF EXISTS ROUTES;
CREATE TABLE ROUTES (ID INTEGER PRIMARY KEY AUTOINCREMENT UNIQUE NOT NULL, NAME TEXT UNIQUE NOT NULL, CATEGORY INTEGER REFERENCES CATEGORIES (ID) ON DELETE CASCADE NOT NULL);

COMMIT TRANSACTION;
PRAGMA foreign_keys = on;</value>
  </data>
  <data name="DatabaseCascadeDeleteWarning" xml:space="preserve">
    <value>Uwaga!
Usunięte zostaną także wszystkie powiązane dane.</value>
  </data>
  <data name="DatabaseDialogFilters" xml:space="preserve">
    <value>Baza danych SQLite3|*.sqlite;*.db|Wszystkie pliki (*.*)|*.*</value>
  </data>
  <data name="DatabaseOverwriteWarning" xml:space="preserve">
    <value>Uwaga!
Baza danych istnieje, czy chcesz nadpisać?</value>
  </data>
  <data name="DeltaTimeFormat" xml:space="preserve">
    <value>+{mm:ss}</value>
  </data>
  <data name="Errors" xml:space="preserve">
    <value>Błędy:</value>
  </data>
  <data name="FinishTimeFormat" xml:space="preserve">
    <value>Czas mety: {0:H:mm:ss}</value>
  </data>
  <data name="InvalidCategoryError" xml:space="preserve">
    <value>Wybrana kategoria jest nieprawidłowa</value>
  </data>
  <data name="InvalidCourseTypeError" xml:space="preserve">
    <value>Wybrany typ sztafety jest nieprawidłowy</value>
  </data>
  <data name="InvalidDataTitle" xml:space="preserve">
    <value>Wprowadzono nieprawidłowe dane</value>
  </data>
  <data name="InvalidDateError" xml:space="preserve">
    <value>Podana data jest nieprawidłowa</value>
  </data>
  <data name="InvalidOrderError" xml:space="preserve">
    <value>Wybrana kolejność jest nieprawidłowa</value>
  </data>
  <data name="InvalidRelayError" xml:space="preserve">
    <value>Wybrana sztafeta jest nieprawidłowa</value>
  </data>
  <data name="None" xml:space="preserve">
    <value>Brak</value>
  </data>
  <data name="NotANumberError" xml:space="preserve">
    <value>Wartość nie jest liczbą</value>
  </data>
  <data name="NullOrEmptyError" xml:space="preserve">
    <value>Pole jest puste lub zawiera tylko białe znaki</value>
  </data>
  <data name="OriginalMessage" xml:space="preserve">
    <value>Oryginalna wiadomość:</value>
  </data>
  <data name="PunchChip" xml:space="preserve">
    <value>Chip</value>
  </data>
  <data name="PunchCode" xml:space="preserve">
    <value>Kod</value>
  </data>
  <data name="PunchTimestamp" xml:space="preserve">
    <value>Czas podbicia</value>
  </data>
  <data name="RelayName" xml:space="preserve">
    <value>Nazwa</value>
  </data>
  <data name="ResultCheckTime" xml:space="preserve">
    <value>Czas kontroli</value>
  </data>
  <data name="ResultChip" xml:space="preserve">
    <value>Chip</value>
  </data>
  <data name="ResultFinishTime" xml:space="preserve">
    <value>Czas mety</value>
  </data>
  <data name="ResultStartTime" xml:space="preserve">
    <value>Czas startu</value>
  </data>
  <data name="RouteName" xml:space="preserve">
    <value>Nazwa</value>
  </data>
  <data name="RouteStepCode" xml:space="preserve">
    <value>Kod</value>
  </data>
  <data name="RouteStepOrder" xml:space="preserve">
    <value>Kolejność</value>
  </data>
  <data name="Searching" xml:space="preserve">
    <value>Wyszukiwanie...</value>
  </data>
  <data name="SiHandlerError" xml:space="preserve">
    <value>Błąd stacji SPORTident</value>
  </data>
  <data name="StartTimeFormat" xml:space="preserve">
    <value>Czas startu: {0:H:mm:ss}</value>
  </data>
  <data name="StartTimeNotPassedWarning" xml:space="preserve">
    <value>Czas rozpoczęcia jeszcze nie minął.
Rozpocząć mimo to?</value>
  </data>
  <data name="TimestampFormat" xml:space="preserve">
    <value>{0:H:mm:ss}</value>
  </data>
  <data name="TournamentCourseType" xml:space="preserve">
    <value>Typ sztafety</value>
  </data>
  <data name="TournamentName" xml:space="preserve">
    <value>Nazwa</value>
  </data>
  <data name="TournamentStartTime" xml:space="preserve">
    <value>Czas rozpoczęcia</value>
  </data>
  <data name="ValueAlreadyExistsError" xml:space="preserve">
    <value>Wartość już istnieje</value>
  </data>
  <data name="Warning" xml:space="preserve">
    <value>Ostrzeżenie</value>
  </data>
</root>